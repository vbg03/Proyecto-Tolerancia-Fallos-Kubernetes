# ğŸš€ Proyecto de Tolerancia a Fallos en Kubernetes

Sistema de microservicios con Flask desplegado en Kubernetes, implementando patrones de tolerancia a fallos como Circuit Breaker, Retry, Failover y Auto-scaling.

## ğŸ“‹ DescripciÃ³n del Proyecto

Este proyecto implementa una aplicaciÃ³n distribuida de e-commerce con tres microservicios principales (Usuarios, Productos y Ã“rdenes), un frontend web y una base de datos MySQL. Todo estÃ¡ orquestado con Kubernetes y configurado con patrones de alta disponibilidad y resiliencia.

### ğŸ—ï¸ Arquitectura

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend  â”‚
â”‚  (Flask)    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚                        â”‚
â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Users API  â”‚   â”‚ Products APIâ”‚   â”‚  Orders API  â”‚
â”‚  (Flask)   â”‚   â”‚   (Flask)   â”‚   â”‚   (Flask)    â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                 â”‚                  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                 â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                 â”‚    MySQL    â”‚
                 â”‚   Database  â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### âœ¨ CaracterÃ­sticas

- **Self-healing**: Kubernetes reinicia automÃ¡ticamente pods fallidos
- **Auto-scaling**: HPA escala pods segÃºn uso de CPU
- **Circuit Breaker**: Previene cascadas de fallos con Istio
- **Retry Policy**: Reintenta requests fallidos automÃ¡ticamente
- **Health Checks**: Liveness y Readiness probes
- **Monitoreo**: Prometheus + Grafana + Kiali
- **Chaos Engineering**: Scripts para simular fallos

---

## ğŸ› ï¸ Requisitos Previos

### Hardware MÃ­nimo
- **CPU**: 4 cores (Intel i5 o superior recomendado)
- **RAM**: 16 GB (8 GB para la VM, 8 GB para el sistema host)
- **Disco**: 20 GB libres

### Software Necesario
- **VirtualBox** 6.1 o superior
- **Vagrant** 2.2 o superior
- **Git** (para clonar el repositorio)

---

## ğŸ“¦ InstalaciÃ³n y ConfiguraciÃ³n

### Paso 1: Clonar el Repositorio

```bash
git clone <url-del-repositorio>
cd <nombre-del-proyecto>
```

### Paso 2: Levantar la MÃ¡quina Virtual

```bash
# Iniciar la VM con Vagrant
vagrant up

# Esto harÃ¡:
# - Crear una VM Ubuntu 22.04
# - Instalar Docker, kubectl, Minikube y Helm
# - Configurar Minikube con 7GB RAM y 3 CPUs
# - Habilitar metrics-server e ingress
```

â±ï¸ **Tiempo estimado**: 15-20 minutos (depende de tu conexiÃ³n a internet)

### Paso 3: Conectarse a la VM

```bash
vagrant ssh
```

### Paso 4: Verificar la InstalaciÃ³n

```bash
# Verificar Minikube
minikube status

# Verificar kubectl
kubectl version --client

# Ver nodos
kubectl get nodes
```

DeberÃ­as ver algo como:
```
NAME       STATUS   ROLES           AGE   VERSION
minikube   Ready    control-plane   5m    v1.28.3
```

---

## ğŸš€ Despliegue de la AplicaciÃ³n

### Paso 1: Construir las ImÃ¡genes Docker

```bash
# AsegÃºrate de estar en el directorio del proyecto dentro de la VM
cd /vagrant

# Configurar Docker para usar el daemon de Minikube
eval $(minikube docker-env)

# Construir imÃ¡genes
docker build -t users-api:latest ./microUsers
docker build -t products-api:latest ./microProductos
docker build -t orders-api:latest ./microOrders
docker build -t frontend:latest ./frontend
```

â±ï¸ **Tiempo estimado**: 5-10 minutos

### Paso 2: Desplegar MySQL

```bash
kubectl apply -f k8s/base/mysql-deployment.yaml

# Esperar a que MySQL estÃ© listo
kubectl wait --for=condition=ready pod -l app=mysql --timeout=300s
```

### Paso 3: Desplegar los Microservicios

```bash
# Desplegar todos los servicios
kubectl apply -f k8s/base/users-deployment.yaml
kubectl apply -f k8s/base/products-deployment.yaml
kubectl apply -f k8s/base/orders-deployment.yaml
kubectl apply -f k8s/base/frontend-deployment.yaml

# Verificar que todos los pods estÃ©n corriendo
kubectl get pods
```

DeberÃ­as ver algo como:
```
NAME                            READY   STATUS    RESTARTS   AGE
mysql-xxx                       1/1     Running   0          2m
users-api-xxx                   1/1     Running   0          1m
products-api-xxx                1/1     Running   0          1m
orders-api-xxx                  1/1     Running   0          1m
frontend-xxx                    1/1     Running   0          1m
```

### Paso 4: Exponer los Servicios

```bash
# Aplicar servicios NodePort
kubectl apply -f expose-all-services.sh

# Ver los puertos asignados
kubectl get svc
```

---

## ğŸŒ Acceder a la AplicaciÃ³n

### Desde tu Navegador (Host)

La aplicaciÃ³n estarÃ¡ disponible en:

- **Frontend**: http://192.168.100.10:30080
- **Users API**: http://192.168.100.10:30002/api/users
- **Products API**: http://192.168.100.10:30003/api/products
- **Orders API**: http://192.168.100.10:30004/api/orders

### Credenciales de Prueba

```
Usuario: juan
ContraseÃ±a: 123
```

O:
```
Usuario: maria
ContraseÃ±a: 456
```

---

## ğŸ“Š Configurar Monitoreo (Opcional pero Recomendado)

### Instalar Istio

```bash
# Descargar Istio
curl -L https://istio.io/downloadIstio | sh -
cd istio-*
export PATH=$PWD/bin:$PATH

# Instalar Istio
istioctl install --set profile=demo -y

# Etiquetar namespace para inyecciÃ³n automÃ¡tica
kubectl label namespace default istio-injection=enabled
```

### Instalar Prometheus, Grafana y Kiali

```bash
cd /vagrant
chmod +x setup-monitoring.sh
./setup-monitoring.sh
```

### Acceder a los Dashboards

En **otra terminal** (desde el host), ejecuta:

```bash
vagrant ssh

# Prometheus (mÃ©tricas)
kubectl port-forward -n istio-system svc/prometheus 9090:9090 --address 0.0.0.0

# Grafana (visualizaciÃ³n)
kubectl port-forward -n istio-system svc/grafana 3000:3000 --address 0.0.0.0

# Kiali (service mesh)
kubectl port-forward -n istio-system svc/kiali 20001:20001 --address 0.0.0.0
```

Luego accede desde tu navegador:
- **Prometheus**: http://192.168.100.10:9090
- **Grafana**: http://192.168.100.10:3000
- **Kiali**: http://192.168.100.10:20001

---

## ğŸ§ª Probar Tolerancia a Fallos

### OpciÃ³n 1: Script Automatizado

```bash
cd /vagrant
chmod +x test-fault-tolerance.sh
./test-fault-tolerance.sh
```

Este script incluye pruebas de:
1. Self-healing (auto-recuperaciÃ³n)
2. HPA (escalado automÃ¡tico)
3. Fallo de base de datos
4. Circuit breaker
5. Retry policy

### OpciÃ³n 2: Chaos Monkey

```bash
cd /vagrant
chmod +x chaos-monkey.sh
./chaos-monkey.sh
```

Este script permite:
- Eliminar pods aleatoriamente
- Atacar servicios especÃ­ficos
- Modo caos continuo
- Ver estadÃ­sticas del cluster

### Pruebas Manuales

#### Eliminar un Pod (Self-healing)
```bash
# Ver pods actuales
kubectl get pods

# Eliminar un pod
kubectl delete pod <nombre-del-pod>

# Kubernetes lo recrearÃ¡ automÃ¡ticamente
kubectl get pods
```

#### Escalar Manualmente
```bash
# Escalar a 5 rÃ©plicas
kubectl scale deployment users-api --replicas=5

# Verificar
kubectl get pods -l app=users-api
```

#### Ver Logs
```bash
# Logs de un servicio especÃ­fico
kubectl logs -l app=users-api --tail=50

# Seguir logs en tiempo real
kubectl logs -l app=users-api -f
```

---

## ğŸ“ˆ Configurar Patrones de Tolerancia

### Activar Circuit Breaker

```bash
kubectl apply -f k8s/base/circuit-breaker.yaml
```

### Activar Retry Policy

```bash
kubectl apply -f k8s/base/retry-policy.yaml
```

### Configurar HPA

```bash
kubectl apply -f k8s/base/hpa.yaml

# Ver estado del HPA
kubectl get hpa
```

---

## ğŸ”§ Comandos Ãštiles

### InformaciÃ³n del Cluster

```bash
# Estado general
kubectl get all

# Pods con mÃ¡s detalles
kubectl get pods -o wide

# Describir un pod
kubectl describe pod <nombre-pod>

# Uso de recursos
kubectl top nodes
kubectl top pods
```

### Debugging

```bash
# Entrar a un pod
kubectl exec -it <nombre-pod> -- /bin/bash

# Ver logs con timestamps
kubectl logs <nombre-pod> --timestamps

# Ver eventos del cluster
kubectl get events --sort-by='.lastTimestamp'
```

### Limpieza

```bash
# Eliminar todos los deployments
kubectl delete deployment --all

# Eliminar todos los servicios (excepto kubernetes)
kubectl delete svc --all

# Reiniciar Minikube
minikube stop
minikube start
```

---

## ğŸ› SoluciÃ³n de Problemas

### Los pods no inician

```bash
# Ver por quÃ© un pod no inicia
kubectl describe pod <nombre-pod>

# Ver logs del pod
kubectl logs <nombre-pod>

# Si es problema de imagen
eval $(minikube docker-env)
docker images  # Verificar que las imÃ¡genes existen
```

### No puedo acceder a la aplicaciÃ³n

```bash
# Verificar servicios
kubectl get svc

# Verificar que los pods estÃ©n Ready
kubectl get pods

# Probar desde dentro del cluster
kubectl run -it --rm debug --image=busybox --restart=Never -- wget -O- http://users-api:5002/health
```

### MySQL no se conecta

```bash
# Ver logs de MySQL
kubectl logs -l app=mysql

# Verificar que el PVC estÃ© bound
kubectl get pvc

# Reiniciar MySQL
kubectl delete pod -l app=mysql
```

### Problemas de recursos

```bash
# Ver uso de recursos
kubectl top nodes
kubectl top pods

# Si Minikube necesita mÃ¡s recursos
minikube stop
minikube delete
minikube start --memory=8192 --cpus=4
```

---

## ğŸ“š Estructura del Proyecto

```
.
â”œâ”€â”€ frontend/                 # AplicaciÃ³n web Flask
â”œâ”€â”€ microUsers/              # API de usuarios
â”œâ”€â”€ microProductos/          # API de productos
â”œâ”€â”€ microOrders/             # API de Ã³rdenes
â”œâ”€â”€ k8s/
â”‚   â”œâ”€â”€ base/                # Manifiestos de Kubernetes
â”‚   â”œâ”€â”€ monitoring/          # ConfiguraciÃ³n de monitoreo
â”‚   â””â”€â”€ chaos/               # Experimentos de caos
â”œâ”€â”€ Vagrantfile              # ConfiguraciÃ³n de la VM
â”œâ”€â”€ setup-k8s.sh            # Script de instalaciÃ³n
â”œâ”€â”€ setup-monitoring.sh      # Script de monitoreo
â”œâ”€â”€ chaos-monkey.sh          # Script de Chaos Engineering
â””â”€â”€ test-fault-tolerance.sh  # Script de pruebas
```

---

## ğŸ¯ Objetivos Cumplidos

- âœ… ImplementaciÃ³n de patrones de tolerancia a fallos
- âœ… Circuit Breaker con Istio
- âœ… Retry policies automÃ¡ticos
- âœ… Auto-scaling con HPA
- âœ… Self-healing de pods
- âœ… Monitoreo con Prometheus y Grafana
- âœ… SimulaciÃ³n de fallos con Chaos Monkey
- âœ… Health checks (liveness y readiness)

---

## ğŸ“ Soporte

Si encuentras algÃºn problema:

1. Verifica que tu hardware cumple con los requisitos mÃ­nimos
2. Revisa los logs con `kubectl logs`
3. Usa `kubectl describe` para mÃ¡s detalles
4. Consulta la secciÃ³n de soluciÃ³n de problemas

---

## ğŸ Comenzar RÃ¡pido (TL;DR)

```bash
# 1. Levantar VM
vagrant up
vagrant ssh

# 2. Construir imÃ¡genes
cd /vagrant
eval $(minikube docker-env)
docker build -t users-api:latest ./microUsers
docker build -t products-api:latest ./microProductos
docker build -t orders-api:latest ./microOrders
docker build -t frontend:latest ./frontend

# 3. Desplegar
kubectl apply -f k8s/base/

# 4. Acceder
# Frontend: http://192.168.100.10:30080
```

Â¡Listo! ğŸ‰